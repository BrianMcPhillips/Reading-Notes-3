Model–view–controller is a software design pattern commonly used for developing user interfaces that divides the related program logic into three interconnected elements. This is done to separate internal representations of information from the ways information is presented to and accepted from the user. Traditionally used for desktop graphical user interfaces this pattern has become popular for designing web applications.
The domain describes the state and holds the business logic. It represents the core of our application and should be agnostic to the view layer. Angular, React, Vue, it shouldn’t matter, we should be able to use our domain regardless of the framework we choose. The data which results from creating and updating articles represents our application’s state. We need a place to hold that data, the store being the perfect candidate for the job. The ArticleStoreFactory implements the publish-subscribe pattern and exports the articleStore as a singleton. The store holds the articles and performs the add, remove and update immutable operations on them. Application services This layer is useful for doing all kinds of operations which are adjacent to the state flow like Ajax calls to retrieve data from the server or state projections. Presentational components are concerned with how things look while container components are concerned with how things work. 
React is an amazing library. Over the last 5 years it has transformed the landscape of frontend development and spawned an incredible ecosystem of tools, libraries, and patterns. Over that time, React has changed quite a bit. As React has evolved, so too have our applications, tools, and approaches. In 2019  React went through one of its biggest changes with React v16.8: The One With Hooks. Combined with the official Context API in v16.3, this update dropped a grenade into the React world. As developers like Kent C. Dodds pointed out, complex state management became something that any React developer could implement—without bringing in tools like Redux, MobX, or Apollo. The guiding light of Model View Controller (MVC) is separating presentation from domain. Why is that important to do? Our application’s “domain” is where we model our perception of the problem and its solution. By making this code separate—without reference to any UI—it could be modeled more correctly, tested more deeply, and presented more numerously.
React provides a declarative API so that you don’t have to worry about exactly what changes on every update. This makes writing applications a lot easier, but it might not be obvious how this is implemented within React. This article explains the choices we made in React’s “diffing” algorithm so that component updates are predictable while being fast enough for high-performance apps. When you use React, at a single point in time you can think of the render() function as creating a tree of React elements. On the next state or props update, that render() function will return a different tree of React elements. React then needs to figure out how to efficiently update the UI to match the most recent tree. When a component updates, the instance stays the same, so that state is maintained across renders. React updates the props of the underlying component instance to match the new element, and calls componentWillReceiveProps() and componentWillUpdate() on the underlying instance.