Quantity over Quality, the more code you write and the faster you write it, the better you will become as a software developer. You learn more by doing and you learn from your mistakes when you are producing a lot of code instead of sitting around theorizing about how to write the perfect code. Writing more code is a better approach than writing the perfect code on your first try.
Clean Code, clean code and bad code can make or break a company. When you rush a product to market and find yourself wading through bad code to add features, fix bugs, and produce new versions; you will see that bad code with tons of 'WTF's" per minute will be the downfall of your company. Bad code will cause newer versions to crash and contain lots of bugs. Bad code may work, but makes it impossible for you to revisit the code that you've written and be able to tell what is happening with the code. Bad code is like tying a complicated knot and then trying to add more strings to the knot. You end up cutting strings to untie the knot which breaks features that were previously working. When adding features to bad code you can create a new features which breaks three or four of the old features. This can cause productivity to slow down until developers demand for a complete redisgn of the existing code base. The product management team will bring in a new team of developers who will be in a race with the current team to dispatch a new code base that works exactly like the old one. Clean code can easily turn into bad code from slapping modules together in a rush, and while the customer and the product manager may want a faster timetable it is on you the developer to defend your timeline for creating clean and scalable code. Clean code is about having code sense, being able to look at messy code and see a list of options or variables that still achieve the same goal. Bad code tries to do too much and clean code should be focused. One module or class to accomplish a single task that will not be disturbed by other modules or classes. Clean code should have meaningful names and should be easy for another person to enhance it later on. Clean code should also be based on the principle of test driven development. Clean code should not duplicate itself.
Test Driven Development, Test driven development is an approach to software development where you write tests first, then use those tests to drive the design and development of your software application. The red green and refactor method: TDD is a way of writing tests for what you would like to accomplish and then writing code that passes that test. The red phase is when you have written a test which decides what you would like to accomplish but the test does not pass. The green phase is when you write code to get the tests to pass without being considered with how the code is being written. The refactor phase is when you are still in the green zone and need to find ways to make the code cleaner and faster. There are a few questions you should ask yourself before putting yourself back into the red zone. Can I make my test suite more expressive? Does my test suite provide reliable feedback? Are my tests isolated? Can I reduce duplication in my test suite or implementation code? Can I make my implementation code more descriptive? Can I implement something more efficiently? If you feel like it is worth it to proceed then put yourself back into the red zone and refactor. 
Test driven development was originally called "Test first Design". Three laws of TDD: You must write a failing test before you write any production code. You must not write more of a test than is sufficient to fail, or fail to compile. You must not write more production code than is sufficient to make the currently failing test pass. The point of the three laws is to promote line by line granularity. As learned in the previous article it is important to do what you can to make tests pass and then give the code a long term survivable structure. Customers care about two things with software, how it makes the machine behave and how easy it is to change the code in the future. If you compromise on either of these issues the value of the code will diminish greatly.